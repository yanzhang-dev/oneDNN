<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>oneDNN: DPC++ Interoperability</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div class="mobile-nav"><i id="nav-btn"></i><a href="index.html">oneAPI Deep Neural Network Library (oneDNN)</a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">
     <a href="index.html">
      <div id="full-name">oneAPI Deep Neural Network Library (oneDNN)</div>
    </a>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
   <div id="projectnumber">1.96.0</div>
  <div>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dev_guide_dpcpp_interoperability.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">DPC++ Interoperability </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p><a class="el" href="group__dnnl__api__sycl__interop.html">API Reference</a></p>
<p></p>
</blockquote>
<h2>Overview</h2>
<p>oneDNN may use the DPC++ runtime for CPU and GPU engines to interact with the hardware. Users may need to use oneDNN with other code that uses DPC++. For that purpose, the library provides API extensions to interoperate with underlying SYCL objects. This interoperability API is defined in the <code>dnnl_sycl.hpp</code> header.</p>
<p>One of the possible scenarios is executing a SYCL kernel for a custom operation not provided by oneDNN. In this case, the library provides all the necessary API to "seamlessly" submit a kernel, sharing the execution context with oneDNN: using the same device and queue.</p>
<p>The interoperability API is provided for two scenarios:</p>
<ul>
<li>Construction of oneDNN objects based on existing SYCL objects</li>
<li>Accessing SYCL objects for existing oneDNN objects</li>
</ul>
<p>The mapping between oneDNN and SYCL objects is provided in the following table:</p>
<table class="doxtable">
<tr>
<th align="left">oneDNN object </th><th align="left">SYCL object(s)  </th></tr>
<tr>
<td align="left">Engine </td><td align="left"><code>cl::sycl::device</code> and <code>cl::sycl::context</code> </td></tr>
<tr>
<td align="left">Stream </td><td align="left"><code>cl::sycl::queue</code> </td></tr>
<tr>
<td align="left">Memory (Buffer-based) </td><td align="left"><code>cl::sycl::buffer&lt;uint8_t, 1&gt;</code> </td></tr>
<tr>
<td align="left">Memory (USM-based) </td><td align="left">Unified Shared Memory (USM) pointer </td></tr>
</table>
<p>The table below summarizes how to construct oneDNN objects based on SYCL objects and how to query underlying SYCL objects for existing oneDNN objects.</p>
<table class="doxtable">
<tr>
<th align="left">oneDNN object </th><th align="left">API to construct oneDNN object </th><th align="left">API to access SYCL object(s)  </th></tr>
<tr>
<td align="left">Engine </td><td align="left"><a class="el" href="namespacednnl_1_1sycl__interop.html#a38a3e5df773eac0eca657c210e3bb937" title="Constructs an engine from SYCL device and context objects. ">dnnl::sycl_interop::make_engine(const cl::sycl::device &amp;, const cl::sycl::context &amp;)</a> </td><td align="left"><a class="el" href="namespacednnl_1_1sycl__interop.html#ac4198f877f40ff0d037b0f8b88611207" title="Returns the SYCL device associated with an engine. ">dnnl::sycl_interop::get_device(const engine &amp;)</a> <br/>
 <a class="el" href="namespacednnl_1_1sycl__interop.html#a351bee0c0076334dd0eb211720448d7e" title="Returns the SYCL context associated with an engine. ">dnnl::sycl_interop::get_context(const engine &amp;)</a> </td></tr>
<tr>
<td align="left">Stream </td><td align="left"><a class="el" href="namespacednnl_1_1sycl__interop.html#a21b76da69a016e68eae8036f16cc51b8" title="Creates an execution stream for a given engine associated with a SYCL queue. ">dnnl::sycl_interop::make_stream(const engine &amp;, cl::sycl::queue &amp;)</a> </td><td align="left"><a class="el" href="namespacednnl_1_1sycl__interop.html#a1e01cd09b687a1698d229705493c6acd" title="Returns the SYCL queue associated with an execution stream. ">dnnl::sycl_interop::get_queue(const stream &amp;)</a> </td></tr>
<tr>
<td align="left">Memory (Buffer-based) </td><td align="left"><a class="el" href="namespacednnl_1_1sycl__interop.html#adc40aabb36c9343ec3e2e5913b57090d" title="Constructs a memory object from a SYCL buffer. ">dnnl::sycl_interop::make_memory(const memory::desc &amp;, const engine &amp;, cl::sycl::buffer&lt;T, ndims&gt; &amp;)</a> </td><td align="left"><a class="el" href="namespacednnl_1_1sycl__interop.html#aa79e54806e23001f638483f5cd3319b4" title="Returns the SYCL buffer associated with a memory object. ">dnnl::sycl_interop::get_buffer&lt;T, ndims&gt;(const memory &amp;)</a> </td></tr>
<tr>
<td align="left">Memory (USM-based) </td><td align="left"><a class="el" href="structdnnl_1_1memory.html" title="Memory object. ">dnnl::memory(const memory::desc &amp;, const engine &amp;, void *)</a> </td><td align="left"><a class="el" href="structdnnl_1_1memory.html#a1b81db911a391cefc31e35bbe9ca95fe" title="Returns the underlying memory buffer. ">dnnl::memory::get_data_handle()</a> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Internally, library buffer-based memory objects use 1D <code>uint8_t</code> SYCL buffers; however, the user may initialize and access memory using SYCL buffers of a different type. In this case, buffers will be reinterpreted to the underlying type <code>cl::sycl::buffer&lt;uint8_t, 1&gt;</code>.</dd></dl>
<h2>SYCL Buffers and DPC++ USM Interfaces for Memory Objects</h2>
<p>The memory model in SYCL 1.2.1 is based on SYCL buffers. DPC++ further extends the programming model with a Unified Shared Memory (USM) alternative, which provides the ability to allocate and use memory in a uniform way on host and DPC++ devices.</p>
<p>oneDNN supports both programming models. USM is the default and can be used with the usual oneDNN <a class="el" href="group__dnnl__api__memory.html">memory API</a>. The buffer-based programming model requires using the interoperability API.</p>
<p>To construct a oneDNN memory object, use one of the following interfaces:</p>
<ul>
<li><p class="startli"><a class="el" href="namespacednnl_1_1sycl__interop.html#ac4f19c86efba789310d287ad1edfb657" title="Creates a memory object. ">dnnl::sycl_interop::make_memory(const memory::desc &amp;, const engine &amp;, sycl_interop::memory_kind kind, void *handle)</a></p>
<p class="startli">Constructs a USM-based or buffer-based memory object depending on memory allocation kind <code>kind</code>. The <code>handle</code> could be one of special values <a class="el" href="group__dnnl__api__memory.html#gaf19cbfbf1f0a9508283f2a25561ae0e4" title="Special pointer value that indicates that the library needs to allocate an underlying buffer for a me...">DNNL_MEMORY_ALLOCATE</a> or <a class="el" href="group__dnnl__api__memory.html#ga96c8752fb3cb4f01cf64bf56190b1343" title="Special pointer value that indicates that a memory object should not have an underlying buffer...">DNNL_MEMORY_NONE</a>, or it could be a user-provided USM pointer. The latter works only when <code>kind</code> is <a class="el" href="namespacednnl_1_1sycl__interop.html#a9c7def46b2c0556f56e2f0aab5fbffeba81e61a0cab904f0e620dd3226f7f6582" title="USM (device, shared, host, or unknown) memory allocation kind. ">dnnl::sycl_interop::memory_kind::usm</a>.</p>
</li>
<li><p class="startli"><a class="el" href="structdnnl_1_1memory.html" title="Memory object. ">dnnl::memory(const memory::desc &amp;, const engine &amp;, void *)</a></p>
<p class="startli">Constructs a USM-based memory object. The call is equivalent to calling the function above with with <code>kind</code> equal to <a class="el" href="namespacednnl_1_1sycl__interop.html#a9c7def46b2c0556f56e2f0aab5fbffeba81e61a0cab904f0e620dd3226f7f6582" title="USM (device, shared, host, or unknown) memory allocation kind. ">dnnl::sycl_interop::memory_kind::usm</a>.</p>
</li>
<li><p class="startli"><a class="el" href="namespacednnl_1_1sycl__interop.html#adc40aabb36c9343ec3e2e5913b57090d" title="Constructs a memory object from a SYCL buffer. ">dnnl::sycl_interop::make_memory(const memory::desc &amp;, const engine &amp;, cl::sycl::buffer&lt;T, ndims&gt; &amp;)</a></p>
<p class="startli">Constructs a buffer-based memory object based on a user-provided SYCL buffer.</p>
</li>
</ul>
<p>To identify whether a memory object is USM-based or buffer-based, <a class="el" href="namespacednnl_1_1sycl__interop.html#a9859fd3ed9a833cc88cb02882051cffb" title="Returns the memory allocation kind associated with a memory object. ">dnnl::sycl_interop::get_memory_kind()</a> query can be used.</p>
<h2>Handling Dependencies with USM</h2>
<p>SYCL queues could be in-order or out-of-order. For out-of-order queues, the order of execution is defined by the dependencies between SYCL tasks. The runtime tracks dependencies based on accessors created for SYCL buffers. USM pointers cannot be used to create accessors and users must handle dependencies on their own using SYCL events.</p>
<p>oneDNN provides two mechanisms to handle dependencies when USM memory is used:</p>
<ol type="1">
<li><p class="startli"><a class="el" href="namespacednnl_1_1sycl__interop.html#afc6c83e27a688e120b72e5355786d4c9" title="Executes computations specified by the primitive in a specified stream and returns a SYCL event...">dnnl::sycl_interop::execute()</a> interface</p>
<p class="startli">This interface enables you to pass dependencies between primitives using SYCL events. In this case, the user is responsible for passing proper dependencies for every primitive execution.</p>
</li>
<li><p class="startli">In-order oneDNN stream</p>
<p class="startli">oneDNN enables you to create in-order streams when submitted primitives are executed in the order they were submitted. Using in-order streams prevents possible read-before-write or concurrent read/write issues. </p>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div class="footer">
    <script>
        $('#top').prependTo($('#side-nav'));
    </script>
    <div class="footer-wrapper">
        <hr>
        <ul class="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>