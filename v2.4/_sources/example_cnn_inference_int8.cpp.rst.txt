.. index:: pair: example; cnn_inference_int8.cpp
.. _doxid-cnn_inference_int8_8cpp-example:

cnn_inference_int8.cpp
======================

This C++ API example demonstrates how to run AlexNet's conv3 and relu3 with int8 data type. Annotated version: :ref:`CNN int8 inference example <doxid-cnn_inference_int8_cpp>`



.. ref-code-block:: cpp

	/*******************************************************************************
	* Copyright 2018-2020 Intel Corporation
	*
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
	*******************************************************************************/
	
	
	
	#include <stdexcept>
	
	#include "oneapi/dnnl/dnnl.hpp"
	
	#include "example_utils.hpp"
	
	using namespace dnnl;
	
	void simple_net_int8(:ref:`engine::kind <doxid-structdnnl_1_1engine_1a2635da16314dcbdb9bd9ea431316bb1a>` engine_kind) {
	    using :ref:`tag <doxid-structdnnl_1_1memory_1a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f>` = :ref:`memory::format_tag <doxid-structdnnl_1_1memory_1a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f>`;
	    using :ref:`dt <doxid-structdnnl_1_1memory_1a8e83474ec3a50e08e37af76c8c075dce>` = :ref:`memory::data_type <doxid-structdnnl_1_1memory_1a8e83474ec3a50e08e37af76c8c075dce>`;
	
	    auto eng = engine(engine_kind, 0);
	    stream s(eng);
	
	    const int batch = 8;
	
	    //[Configure tensor shapes]
	    // AlexNet: conv3
	    // {batch, 256, 13, 13} (x)  {384, 256, 3, 3}; -> {batch, 384, 13, 13}
	    // strides: {1, 1}
	    :ref:`memory::dims <doxid-structdnnl_1_1memory_1afdd20764d58c0b517d5a31276672aeb8>` conv_src_tz = {batch, 256, 13, 13};
	    :ref:`memory::dims <doxid-structdnnl_1_1memory_1afdd20764d58c0b517d5a31276672aeb8>` conv_weights_tz = {384, 256, 3, 3};
	    :ref:`memory::dims <doxid-structdnnl_1_1memory_1afdd20764d58c0b517d5a31276672aeb8>` conv_bias_tz = {384};
	    :ref:`memory::dims <doxid-structdnnl_1_1memory_1afdd20764d58c0b517d5a31276672aeb8>` conv_dst_tz = {batch, 384, 13, 13};
	    :ref:`memory::dims <doxid-structdnnl_1_1memory_1afdd20764d58c0b517d5a31276672aeb8>` conv_strides = {1, 1};
	    :ref:`memory::dims <doxid-structdnnl_1_1memory_1afdd20764d58c0b517d5a31276672aeb8>` conv_padding = {1, 1};
	    //[Configure tensor shapes]
	
	    //[Choose scaling factors]
	    // Choose scaling factors for input, weight, output and bias quantization
	    const std::vector<float> src_scales = {1.8f};
	    const std::vector<float> weight_scales = {2.0f};
	    const std::vector<float> bias_scales = {1.0f};
	    const std::vector<float> dst_scales = {0.55f};
	
	    // Choose channel-wise scaling factors for convolution
	    std::vector<float> conv_scales(384);
	    const int scales_half = 384 / 2;
	    std::fill(conv_scales.begin(), conv_scales.begin() + scales_half, 0.3f);
	    std::fill(conv_scales.begin() + scales_half + 1, conv_scales.end(), 0.8f);
	    //[Choose scaling factors]
	
	    //[Set scaling mask]
	    const int src_mask = 0;
	    const int weight_mask = 0;
	    const int bias_mask = 0;
	    const int dst_mask = 0;
	    const int conv_mask = 2; // 1 << output_channel_dim
	    //[Set scaling mask]
	
	    // Allocate input and output buffers for user data
	    std::vector<float> user_src(batch * 256 * 13 * 13);
	    std::vector<float> user_dst(batch * 384 * 13 * 13);
	
	    // Allocate and fill buffers for weights and bias
	    std::vector<float> conv_weights(product(conv_weights_tz));
	    std::vector<float> conv_bias(product(conv_bias_tz));
	
	    //[Allocate buffers]
	    auto user_src_memory = memory({{conv_src_tz}, dt::f32, tag::nchw}, eng);
	    write_to_dnnl_memory(user_src.data(), user_src_memory);
	    auto user_weights_memory
	            = memory({{conv_weights_tz}, dt::f32, tag::oihw}, eng);
	    write_to_dnnl_memory(conv_weights.data(), user_weights_memory);
	    auto user_bias_memory = memory({{conv_bias_tz}, dt::f32, tag::x}, eng);
	    write_to_dnnl_memory(conv_bias.data(), user_bias_memory);
	    //[Allocate buffers]
	
	    //[Create convolution memory descriptors]
	    auto conv_src_md = :ref:`memory::desc <doxid-structdnnl_1_1memory_1_1desc>`({conv_src_tz}, dt::u8, :ref:`tag::any <doxid-group__dnnl__api__attributes_1gga0ad94cbef13dce222933422bfdcfa725a100b8cad7cf2a56f6df78f171f97a1ec>`);
	    auto conv_bias_md = :ref:`memory::desc <doxid-structdnnl_1_1memory_1_1desc>`({conv_bias_tz}, dt::s8, :ref:`tag::any <doxid-group__dnnl__api__attributes_1gga0ad94cbef13dce222933422bfdcfa725a100b8cad7cf2a56f6df78f171f97a1ec>`);
	    auto conv_weights_md = :ref:`memory::desc <doxid-structdnnl_1_1memory_1_1desc>`({conv_weights_tz}, dt::s8, :ref:`tag::any <doxid-group__dnnl__api__attributes_1gga0ad94cbef13dce222933422bfdcfa725a100b8cad7cf2a56f6df78f171f97a1ec>`);
	    auto conv_dst_md = :ref:`memory::desc <doxid-structdnnl_1_1memory_1_1desc>`({conv_dst_tz}, dt::u8, :ref:`tag::any <doxid-group__dnnl__api__attributes_1gga0ad94cbef13dce222933422bfdcfa725a100b8cad7cf2a56f6df78f171f97a1ec>`);
	    //[Create convolution memory descriptors]
	
	    //[Create convolution descriptor]
	    auto conv_desc = :ref:`convolution_forward::desc <doxid-structdnnl_1_1convolution__forward_1_1desc>`(:ref:`prop_kind::forward <doxid-group__dnnl__api__attributes_1ggac7db48f6583aa9903e54c2a39d65438fa965dbaac085fc891bfbbd4f9d145bbc8>`,
	            :ref:`algorithm::convolution_direct <doxid-group__dnnl__api__attributes_1gga00377dd4982333e42e8ae1d09a309640a5028ad8f818a45333a8a0eefad35c5c0>`, conv_src_md, conv_weights_md,
	            conv_bias_md, conv_dst_md, conv_strides, conv_padding,
	            conv_padding);
	    //[Create convolution descriptor]
	
	    //[Configure scaling]
	    primitive_attr conv_attr;
	    conv_attr.set_output_scales(conv_mask, conv_scales);
	    //[Configure scaling]
	
	    //[Configure post-ops]
	    const float ops_scale = 1.f;
	    const float ops_alpha = 0.f; // relu negative slope
	    const float ops_beta = 0.f;
	    :ref:`post_ops <doxid-structdnnl_1_1post__ops>` ops;
	    ops.:ref:`append_eltwise <doxid-structdnnl_1_1post__ops_1a28460923ad579c780e4027a6256fe207>`(ops_scale, :ref:`algorithm::eltwise_relu <doxid-group__dnnl__api__attributes_1gga00377dd4982333e42e8ae1d09a309640aba09bebb742494255b90b43871c01c69>`, ops_alpha, ops_beta);
	    conv_attr.set_post_ops(ops);
	    //[Configure post-ops]
	
	    // check if int8 convolution is supported
	    try {
	        :ref:`convolution_forward::primitive_desc <doxid-structdnnl_1_1convolution__forward_1_1primitive__desc>`(conv_desc, conv_attr, eng);
	    } catch (:ref:`error <doxid-structdnnl_1_1error>` &e) {
	        if (e.status == :ref:`dnnl_unimplemented <doxid-group__dnnl__api__utils_1ggad24f9ded06e34d3ee71e7fc4b408d57aa3a8579e8afc4e23344cd3115b0e81de1>`)
	            throw example_allows_unimplemented {
	                    "No int8 convolution implementation is available for this "
	                    "platform.\n"
	                    "Please refer to the developer guide for details."};
	
	        // on any other error just re-throw
	        throw;
	    }
	
	    //[Create convolution primitive descriptor]
	    auto conv_prim_desc
	            = :ref:`convolution_forward::primitive_desc <doxid-structdnnl_1_1convolution__forward_1_1primitive__desc>`(conv_desc, conv_attr, eng);
	    //[Create convolution primitive descriptor]
	
	    //[Quantize data and weights]
	    auto conv_src_memory = memory(conv_prim_desc.src_desc(), eng);
	    primitive_attr src_attr;
	    src_attr.set_output_scales(src_mask, src_scales);
	    auto src_reorder_pd
	            = :ref:`reorder::primitive_desc <doxid-structdnnl_1_1reorder_1_1primitive__desc>`(eng, user_src_memory.get_desc(), eng,
	                    conv_src_memory.get_desc(), src_attr);
	    auto src_reorder = reorder(src_reorder_pd);
	    src_reorder.execute(s, user_src_memory, conv_src_memory);
	
	    auto conv_weights_memory = memory(conv_prim_desc.weights_desc(), eng);
	    primitive_attr weight_attr;
	    weight_attr.set_output_scales(weight_mask, weight_scales);
	    auto weight_reorder_pd
	            = :ref:`reorder::primitive_desc <doxid-structdnnl_1_1reorder_1_1primitive__desc>`(eng, user_weights_memory.get_desc(), eng,
	                    conv_weights_memory.get_desc(), weight_attr);
	    auto weight_reorder = reorder(weight_reorder_pd);
	    weight_reorder.execute(s, user_weights_memory, conv_weights_memory);
	
	    auto conv_bias_memory = memory(conv_prim_desc.bias_desc(), eng);
	    primitive_attr bias_attr;
	    bias_attr.set_output_scales(bias_mask, bias_scales);
	    auto bias_reorder_pd
	            = :ref:`reorder::primitive_desc <doxid-structdnnl_1_1reorder_1_1primitive__desc>`(eng, user_bias_memory.get_desc(), eng,
	                    conv_bias_memory.get_desc(), bias_attr);
	    auto bias_reorder = reorder(bias_reorder_pd);
	    bias_reorder.execute(s, user_bias_memory, conv_bias_memory);
	    //[Quantize data and weights]
	
	    auto conv_dst_memory = memory(conv_prim_desc.dst_desc(), eng);
	
	    //[Create convolution primitive]
	    auto conv = :ref:`convolution_forward <doxid-structdnnl_1_1convolution__forward>`(conv_prim_desc);
	    conv.execute(s,
	            {{:ref:`DNNL_ARG_SRC <doxid-group__dnnl__api__primitives__common_1gac37ad67b48edeb9e742af0e50b70fe09>`, conv_src_memory},
	                    {:ref:`DNNL_ARG_WEIGHTS <doxid-group__dnnl__api__primitives__common_1gaf279f28c59a807e71a70c719db56c5b3>`, conv_weights_memory},
	                    {:ref:`DNNL_ARG_BIAS <doxid-group__dnnl__api__primitives__common_1gad0cbc09942aba93fbe3c0c2e09166f0d>`, conv_bias_memory},
	                    {:ref:`DNNL_ARG_DST <doxid-group__dnnl__api__primitives__common_1ga3ca217e4a06d42a0ede3c018383c388f>`, conv_dst_memory}});
	    //[Create convolution primitive]
	
	    auto user_dst_memory = memory({{conv_dst_tz}, dt::f32, tag::nchw}, eng);
	    write_to_dnnl_memory(user_dst.data(), user_dst_memory);
	    primitive_attr dst_attr;
	    dst_attr.set_output_scales(dst_mask, dst_scales);
	    auto dst_reorder_pd
	            = :ref:`reorder::primitive_desc <doxid-structdnnl_1_1reorder_1_1primitive__desc>`(eng, conv_dst_memory.get_desc(), eng,
	                    user_dst_memory.get_desc(), dst_attr);
	    auto dst_reorder = reorder(dst_reorder_pd);
	    dst_reorder.execute(s, conv_dst_memory, user_dst_memory);
	    //[Dequantize the result]
	
	    s.wait();
	}
	
	int main(int argc, char **argv) {
	    return handle_example_errors(
	            simple_net_int8, parse_engine_kind(argc, argv));
	}
